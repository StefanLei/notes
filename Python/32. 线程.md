### Python 线程

> threading 模块

##### 函数式多线程

```python
import threading
import time
import random

def test():
    for item in range(10):
        time.sleep(random.random())
        print(threading.current_thread().getName())


t1 = threading.Thread(target=test, args=())
t2 = threading.Thread(target=test, args=())

# 线程开始
t1.start()
t2.start()

```

##### 类式多线程

```python
import threading
import time
import random

# 通过继承，然后重写 run 方法。
class Mythread(threading.Thread):

    def run(self):
        for item in range(10):
            time.sleep(random.random())
            print(threading.current_thread().getName())


t1 = Mythread()
t2 = Mythread()

t1.start()
t2.start()
```

---

##### 线程常用方法

```python
# join 方法，表示当前线程执行完成后，再执行其他线程（一般是主线程）

import threading
import time
import random

class Mythread(threading.Thread):

    def run(self):
        for item in range(10):
            time.sleep(random.random())
            print(threading.current_thread().getName())


t1 = Mythread()
t2 = Mythread()

t1.start()

# t1 线程执行完成后，主线程才执行（t2才开始）
t1.join()

t2.start()

```

---

#### 互斥锁

在多线程中，如果要解决线程中，全局变量读写的问题，那么可以用锁来解决，这使用互斥锁。

某个线程要共享数据时，先将其锁定，此时资源的状态为“锁定”，其他线程不能更改；直到该线程释放资源，将资源的状态变成“非锁定”，其他的线程才能再次锁定该资源。互斥锁保证了每次只有一个线程进入写入操作，从而保证了多线程情况下数据的正确性。 

互斥锁一共有3个语义

- 创建锁 `mutex = threading.Lock()`
- 锁定 `mutex.acquire(blocking)` 里面可以加blocking(等待的时间)或者不加，不加就会一直等待（堵塞） 
- 释放 `mutex.release()`

或者使用 `with mutex`



```python
import threading
import time
import random

n = 0

# 这里就是创建了一个互斥锁
muxte = threading.Lock()


def test1():
    global n
    for item in range(10):
        with muxte:
            n = n + 1


def test2():
    global n
    for item in range(10):
        with muxte:
            n = n - 1


t1 = threading.Thread(target=test1)
t2 = threading.Thread(target=test2)

t1.start()
t2.start()

t1.join()
t2.join()

print(n)

```

